'use strict';

<<<<<<< HEAD
=======
const hasParentPointers = Symbol('Mongoose.helpers.setParentPointers');

>>>>>>> ad5fb97f904ab5dd8f22120c79ccd799292d93c5
/*!
 * Set `$parentSchema` on all schema types, and `$schemaType` on single
 * nested docs.
 *
 * This is a slow path function, should only run when model is compiled
 */

<<<<<<< HEAD
module.exports = function setParentPointers(schema, skipRecursion) {
=======
module.exports = function setParentPointers(schema) {
  if (schema[hasParentPointers]) {
    return;
  }
  schema[hasParentPointers] = true;
>>>>>>> ad5fb97f904ab5dd8f22120c79ccd799292d93c5
  for (const path of Object.keys(schema.paths)) {
    const schemaType = schema.paths[path];
    if (schemaType.schema != null) {
      Object.defineProperty(schemaType.schema, '$schemaType', {
        configurable: true,
        writable: false,
        enumerable: false,
        value: schemaType
      });
    }
    Object.defineProperty(schemaType, '$parentSchema', {
      configurable: true,
      writable: false,
      enumerable: false,
      value: schema
    });
  }

<<<<<<< HEAD
  // `childSchemas` contains all descendant schemas, so no need to recurse
  // further.
  if (skipRecursion) {
    return;
  }

  for (const obj of schema.childSchemas) {
    setParentPointers(obj.schema, true);
=======
  for (const path of Object.keys(schema.paths)) {
    const type = schema.paths[path];
    if (type.$isSingleNested || type.$isMongooseDocumentArray) {
      setParentPointers(type.schema, false);
    }
>>>>>>> ad5fb97f904ab5dd8f22120c79ccd799292d93c5
  }
};